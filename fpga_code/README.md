# FPGA design overview

## Introduction

I suspect these files may be the most likely to help someone in the future, not the sequence alignment part (there
are plenty of other papers and projects that have had more than one undergrad student-year of work) but as a primer
for designing an accelerator of your own as a personal project or prototype. This may be of particular interest for
Part II and III students at Cambridge, because you are likely to use the same hardware and software as I did.

I used a DE1 SoC board, which is the standard board used in
[2nd year ECAD and Architecture labs](https://www.cl.cam.ac.uk/teaching/1920/ECAD+Arch/) on the Cambridge Computer
Science BA, and that material is a basic prerequisite for this project. The
[additional materials](https://www.cl.cam.ac.uk/teaching/1920/ECAD+Arch/additional.html) are not taught directly, but
very useful, especially the ones for getting Linux running on the HPS (the ARM processor on the same chip next to the
FPGA).

## Accelerator architecture

The accelerator I made was built around a SystemVerilog module. This took as input the data it needed to run the
sequence alignment, would perform the alignment and write it out of its outputs (using some basic enable/finished flags
to control the module). Naturally, this module was made up of many smaller modules but that's not too important here.
My final version of this module can be found in
[Sequence_Aligner/med_solver_with_ram.sv](./Sequence_Aligner/med_solver_with_ram.sv)

This accelerator module was wrapped up in another module
[med_solver_with_ram_avalon.sv](./Sequence_Aligner/med_solver_with_ram_avalon.sv) that used an Avalon interface to
communicate between the HPS and FPGA. The HPS ran a basic Linux-based OS, and this Avalon interface made the FPGA
appear like a block of memory from the perspective of a program running on the HPS; it could read and write data to it
using addresses. What the FPGA chose to do with these requests were up to it, and are defined in that wrapper module,
but this is the medium used when designing a protocol to control and communicate with the Verilog module on the FPGA.

The protocol I used was just to assign some of the address space for FPGA read/HPS write to each
sequence being submitted for alignment, and nearly all of the FPGA write/HPS read address space for the sequence
pointers that were produced. Address 0 was the magic control address, where metadata (sequence lengths) were written
at the start of an alignment, alongside a flag to tell the alignment module that the sequences have been fully written
over and that it is free to start. Reading from this address would give alignment metadata (the location of the best
cell in the grid), and alignment status so the HPS could know when to start reading the results out. During alignment,
the HPS would just continuously poll address 0 until the flag in that value was set to say the alignment had finished.
There are more efficient ways of doing this, but the HPS had nothing else to do in the mean time so there was no harm in
it for me.

This control logic is the C program found in [c_interface/](./c_interface/) and most of the generic control logic can
be found in [device_manager.c](./c_interface/device_manager.c) The address space needs to be initialised before work can
begin using `device_init()` in that file, and take care to treat pointers to this address space as `volatile`, because
it is not real memory, just an FPGA pretending to be memory, and treating it as real memory is going to lead to
undefined behaviour.

Quartus Prime 16.1 was the software I used to synthesise the FPGA images. This is not the newest version, I have heard
anecdotal reports of difficulty synthesising for this board using later versions, and it is the version that is
recommended by the CompArch Group and for the IB labs, to quote them:
> Important note: we are using version 16.1 of Quartus for these labs, not the most recent version.
> This version has good performance for the low-end Cyclone V FPGAs in our boards: more recent versions are optimised
> towards larger FPGAs and have greater memory demands when compiling.

[My Qsys project](./Sequence_Aligner/accelerator_hps.qsys) should be a good starting point for showing how to instantiate
the HPS in the FPGA project, so the relevant logic can be synthesised to join the two together. The
[med_solver_with_ram_avalon.sv](./Sequence_Aligner/med_solver_with_ram_avalon.sv) wrapper is instantiated in this Qsys
project, and then [toplevel.sv](./Sequence_Aligner/toplevel.sv) instantiates the module generated by Qsys, and this is
the module that is synthesised for the FPGA. [toplevel.sv](./Sequence_Aligner/toplevel.sv) also deals routing the pins
out of the FPGA to the correct parts of Verilog (especially for things like the DDR3 RAM chips).

## Further reading for using the DE1 SoC board
 - [Cambridge Computer Science 2nd year ECAD and Architecture labs](https://www.cl.cam.ac.uk/teaching/1920/ECAD+Arch/)
 - [Additional materials](https://www.cl.cam.ac.uk/teaching/1920/ECAD+Arch/additional.html) for those labs
 - [Cornell ECE5760 - Advanced Microcontroller Design and system-on-chip](
    http://people.ece.cornell.edu/land/courses/ece5760/) - a similar, but longer and more detailed hardware course at
    Cornell University also using Terasic DE1 SoC boards.
    - [Course lectures on YouTube](https://www.youtube.com/playlist?list=PLKcjQ_UFkrd7BGMJIYMn0pSk65dB8OYG-)
    - [SoC-FPGA Design Guide](
       http://people.ece.cornell.edu/land/courses/ece5760/DE1_SOC/SoC-FPGA%20Design%20Guide_EPFL.pdf)
       (pretty much a manual for the board, just better than Terasic's in my opinion).
 - [Terasic (board makers) resources](
    http://www.terasic.com.tw/cgi-bin/page/archive.pl?Language=English&CategoryNo=205&No=836&PartNo=4), CL boards are
    rev. F.
 - [Cyclone V (the FPGA series) handbook](
    https://www.intel.com/content/dam/www/programmable/us/en/pdfs/literature/hb/cyclone-v/cv_5v2.pdf) from Intel
    - [Intel's (was Altera's) documentation](
       https://www.intel.com/content/www/us/en/programmable/documentation/lit-ug.html) on other features are all pretty
       good, if a little verbose. Authoritative, but can take some sifting to work out which parts you want.
